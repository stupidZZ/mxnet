/*!
 *  Copyright (c) 2015 by Contributors
 * \file image_det_aug_multi_scale.cc
 * \brief Default augmenter.
 */
#include <mxnet/base.h>
#include <utility>
#include <string>
#include <algorithm>
#include <vector>
#include <cmath>
#include "./image_augmenter.h"
#include "../common/utils.h"

#define DEBUG_FLAG 0
namespace mxnet {
namespace io {

using nnvm::Tuple;

namespace image_det_aug_multi_scale_enum {
enum ImageDetAugMultiScaleCropEmitMode {kCenter, kOverlap};
enum ImageDetAugMultiScaleResizeMode {kForce, kShrink, kFit, kForceFit};
}

/*! \brief image detection augmentation parameters*/
struct MultiScaleImageDetAugmentParam : public dmlc::Parameter<MultiScaleImageDetAugmentParam> {
  /*! \brief short side scales */
  Tuple<int> short_side_scales;
  /*! \brief long side scales */
  Tuple<int> long_side_scales;
  /*! \brief min areas */
  Tuple<float> min_area_ratios;
  /*! \brief max areas*/
  Tuple<float> max_area_ratios;
  /*! \brief target area */
  int target_area;
  /*! \brief num of crop samplers */
  int num_scale_sampler;
  /*! \brief random mirror prob */
  float rand_mirror_prob;
  /*! \brief filled color while padding */
  int fill_value;
  /*! \brief interpolation method 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand  */
  int inter_method;
  /*! \brief shape of the image data */
  TShape data_shape;
  /*! \brief resize mode, 0-force
   * 1-Shrink to data_shape, preserve ratio,
   * 2-fit to data_shape, preserve ratio
   */
  int resize_mode;
  // declare parameters
  DMLC_DECLARE_PARAMETER(MultiScaleImageDetAugmentParam) {
    DMLC_DECLARE_FIELD(short_side_scales).set_default(Tuple<int>({600}))
        .describe("Augmentation Param: short side scales.");
    DMLC_DECLARE_FIELD(long_side_scales).set_default(Tuple<int>({1000}))
        .describe("Augmentation Param: long side scales.");
    DMLC_DECLARE_FIELD(min_area_ratios).set_default(Tuple<float>({0}))
        .describe("Augmentation Param: min_areas.");
    DMLC_DECLARE_FIELD(max_area_ratios).set_default(Tuple<float>({1000}))
        .describe("Augmentation Param: max_areas.");
    DMLC_DECLARE_FIELD(target_area).set_default(224*224)
        .describe("Augmentation Param: target area.");
    DMLC_DECLARE_FIELD(num_scale_sampler).set_default(0)
        .describe("Augmentation Param: num of crop samplers.");
    DMLC_DECLARE_FIELD(rand_mirror_prob).set_default(0.0f)
        .describe("Augmentation Param: Probability to apply horizontal flip aka. mirror.");
    DMLC_DECLARE_FIELD(fill_value).set_default(127)
        .describe("Augmentation Param: Filled color value while padding.");
    DMLC_DECLARE_FIELD(inter_method).set_default(1)
        .describe("Augmentation Param: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.");
    DMLC_DECLARE_FIELD(data_shape)
        .set_expect_ndim(3).enforce_nonzero()
        .describe("Dataset Param: Shape of each instance generated by the DataIter.");
    DMLC_DECLARE_FIELD(resize_mode)
      .add_enum("force", image_det_aug_multi_scale_enum::kForce)
      .add_enum("shrink", image_det_aug_multi_scale_enum::kShrink)
      .add_enum("fit", image_det_aug_multi_scale_enum::kFit)
      .add_enum("forcefit", image_det_aug_multi_scale_enum::kForceFit)
      .set_default(image_det_aug_multi_scale_enum::kForce)
      .describe("Augmentation Param: How image data fit in data_shape. "
                "force: force reshape to data_shape regardless of aspect ratio; "
                "shrink: ensure each side fit in data_shape, preserve aspect ratio; "
                "fit: fit image to data_shape, preserve ratio, will upscale if applicable."
                "forcefit: fit image to data_shape, preserve ratio, will fill border with fill_value if the shape is smaller than data_shape.");
  }
};

DMLC_REGISTER_PARAMETER(MultiScaleImageDetAugmentParam);

std::vector<dmlc::ParamFieldInfo> ListMultiScaleDetAugParams() {
  return MultiScaleImageDetAugmentParam::__FIELDS__();
}

#if MXNET_USE_OPENCV
using Rect = cv::Rect_<float>;

#ifdef _MSC_VER
#define M_PI CV_PI
#endif

/*! \brief helper class for better detection label handling */
class ImageDetLabel {
 public:
  /*! \brief Helper struct to store the coordinates and id for each object */
  struct ImageDetObject {
    float id;
    float left;
    float top;
    float right;
    float bottom;
    std::vector<float> extra;  // store extra info other than id and coordinates

     /*! \brief Return converted Rect object */
     Rect ToRect() const {
       return Rect(left, top, right - left, bottom - top);
     }

     /*! \brief Return projected coordinates according to new region */
     ImageDetObject Project(Rect box) const {
       ImageDetObject ret = *this;
       ret.left = std::max(0.f, (ret.left - box.x) / box.width);
       ret.top = std::max(0.f, (ret.top - box.y) / box.height);
       ret.right = std::min(1.f, (ret.right - box.x) / box.width);
       ret.bottom = std::min(1.f, (ret.bottom - box.y) / box.height);
       return ret;
     }

     /*! \brief Return Horizontally fliped coordinates */
     ImageDetObject HorizontalFlip() const {
       ImageDetObject ret = *this;
       ret.left = 1.f - this->right;
       ret.right = 1.f - this->left;
       return ret;
     }
  };  // struct ImageDetObject

  /*! \brief constructor from raw array of detection labels */
  explicit ImageDetLabel(const std::vector<float> &raw_label) {
    FromArray(raw_label);
  }

  /*! \brief construct from raw array with following format
   * header_width, object_width, (extra_headers...),
   * [id, xmin, ymin, xmax, ymax, (extra_object_info)] x N
   */
  void FromArray(const std::vector<float> &raw_label) {
    int label_width = static_cast<int>(raw_label.size());
    CHECK_GE(label_width, 7);  // at least 2(header) + 5(1 object)
    int header_width = static_cast<int>(raw_label[0]);
    CHECK_GE(header_width, 2);
    object_width_ = static_cast<int>(raw_label[1]);
    CHECK_GE(object_width_, 5);  // id, x1, y1, x2, y2...
    header_.assign(raw_label.begin(), raw_label.begin() + header_width);
    int num = (label_width - header_width) / object_width_;
    CHECK_EQ((label_width - header_width) % object_width_, 0);
    objects_.reserve(num);
    for (int i = header_width; i < label_width; i += object_width_) {
      ImageDetObject obj;
      auto it = raw_label.cbegin() + i;
      obj.id = *(it++);
      obj.left = *(it++);
      obj.top = *(it++);
      obj.right = *(it++);
      obj.bottom = *(it++);
      obj.extra.assign(it, it - 5 + object_width_);
      objects_.push_back(obj);
      CHECK_GT(obj.right, obj.left);
      CHECK_GT(obj.bottom, obj.top);
    }
  }

  /*! \brief Convert back to raw array */
  std::vector<float> ToArray() const {
    std::vector<float> out(header_);
    out.reserve(out.size() + objects_.size() * object_width_);
    for (auto& obj : objects_) {
      out.push_back(obj.id);
      out.push_back(obj.left);
      out.push_back(obj.top);
      out.push_back(obj.right);
      out.push_back(obj.bottom);
      out.insert(out.end(), obj.extra.begin(), obj.extra.end());
    }
    return out;
  }

  /*! \brief Intersection over Union between two rects */
  static float RectIOU(Rect a, Rect b) {
    float intersect = (a & b).area();
    if (intersect <= 0.f) return 0.f;
    return intersect / (a.area() + b.area() - intersect);
  }

  /*! \brief try crop image with given crop_box
   * return false if fail to meet any of the constraints
   * convert all objects if success
   */
  bool TryCrop(const Rect crop_box,
    const float min_crop_overlap, const float max_crop_overlap,
    const float min_crop_sample_coverage, const float max_crop_sample_coverage,
    const float min_crop_object_coverage, const float max_crop_object_coverage,
    const int crop_emit_mode, const float emit_overlap_thresh) {
    if (objects_.size() < 1) {
      return true;  // no object, raise error or just skip?
    }
    // check if crop_box valid
    bool valid = false;
    if (min_crop_overlap > 0.f && max_crop_overlap < 1.f &&
        min_crop_sample_coverage > 0.f && max_crop_sample_coverage < 1.f &&
        min_crop_object_coverage > 0.f && max_crop_object_coverage < 1.f) {
      for (auto& obj : objects_) {
        Rect gt_box = obj.ToRect();
        if (min_crop_overlap > 0.f || max_crop_overlap < 1.f) {
          float ovp = RectIOU(crop_box, gt_box);
          if (ovp < min_crop_overlap || ovp > max_crop_overlap) {
            continue;
          }
        }
        if (min_crop_sample_coverage > 0.f || max_crop_sample_coverage < 1.f) {
          float c = (crop_box & gt_box).area() / crop_box.area();
          if (c < min_crop_sample_coverage || c > max_crop_sample_coverage) {
            continue;
          }
        }
        if (min_crop_object_coverage > 0.f || max_crop_object_coverage < 1.f) {
          float c = (crop_box & gt_box).area() / gt_box.area();
          if (c < min_crop_object_coverage || c > max_crop_object_coverage) {
            continue;
          }
        }
        valid = true;
        break;
      }
    } else {
      valid = true;
    }

    if (!valid) return false;
    // transform ground-truth labels
    std::vector<ImageDetObject> new_objects;
    for (auto iter = objects_.begin(); iter != objects_.end(); ++iter) {
      if (image_det_aug_multi_scale_enum::kCenter == crop_emit_mode) {
        float center_x = (iter->left + iter->right) * 0.5f;
        float center_y = (iter->top + iter->bottom) * 0.5f;
        if (!crop_box.contains(cv::Point2f(center_x, center_y))) {
          continue;
        }
        new_objects.push_back(iter->Project(crop_box));
      } else if (image_det_aug_multi_scale_enum::kOverlap == crop_emit_mode) {
        Rect gt_box = iter->ToRect();
        float overlap = (crop_box & gt_box).area() / gt_box.area();
        if (overlap > emit_overlap_thresh) {
          new_objects.push_back(iter->Project(crop_box));
        }
      }
    }
    if (new_objects.size() < 1) return false;
    objects_ = new_objects;  // replace the old objects
    return true;
  }

  /*! \brief try pad image with given pad_box
   * convert all objects afterwards
   */
  bool TryPad(const Rect pad_box) {
    // update all objects inplace
    for (auto it = objects_.begin(); it != objects_.end(); ++it) {
      *it = it->Project(pad_box);
    }
    return true;
  }

  /*! \brief flip image and object coordinates horizontally */
  bool TryMirror() {
    // flip all objects horizontally
    for (auto it = objects_.begin(); it != objects_.end(); ++it) {
      *it = it->HorizontalFlip();
    }
    return true;
  }
  
  /*! \brief Mute the labels by area constraint. The id of muted labels is -1*/
  bool MuteLabels(float min_normed_area, float max_normed_area, int min_valid_objects = 1) {
    int valid_objects_num = 0;
    for (auto it = objects_.begin(); it != objects_.end(); ++it) {
        float normed_area = (it->right-it->left) * (it->bottom - it->top);
        if(normed_area > min_normed_area && normed_area <= max_normed_area) {
            valid_objects_num++;
        }
        
        if(DEBUG_FLAG) {
            printf("left:%f right:%f top:%f bottom:%f area_ratio:%f min_normed_area:%f max_normed_area:%f\n", 
            it->left, it->right, it->top, it->bottom,normed_area, min_normed_area, max_normed_area);
        }
    }
    
    if(valid_objects_num >= min_valid_objects) {
        for (auto it = objects_.begin(); it != objects_.end(); ++it) {
            float normed_area = (it->right-it->left) * (it->bottom - it->top);
            if(normed_area <= min_normed_area || normed_area > max_normed_area) {
                it->id = -1;
                if(DEBUG_FLAG) {
                    printf("come to here!\n");
                }
            }
        }
        return true;
    } else {
        return false;
    }
  }

 private:
  /*! \brief width for each object information, 5 at least */
  int object_width_;
  /*! \brief vector to store original header info */
  std::vector<float> header_;
  /*! \brief storing objects in more convenient formats */
  std::vector<ImageDetObject> objects_;
};  // class ImageDetLabel

/*! \brief helper class to do image augmentation */
class MultiScaleImageDetAugmenter : public ImageAugmenter {
 public:
  // contructor
  MultiScaleImageDetAugmenter() {}

  void Init(const std::vector<std::pair<std::string, std::string> >& kwargs) override {
    std::vector<std::pair<std::string, std::string> > kwargs_left;
    kwargs_left = param_.InitAllowUnknown(kwargs);

    CHECK((param_.inter_method >= 1 && param_.inter_method <= 4) ||
     (param_.inter_method >= 9 && param_.inter_method <= 10))
      << "invalid inter_method: valid value 0,1,2,3,9,10";

    // validate crop parameters
    ValidateCropParameters(&param_.long_side_scales, param_.num_scale_sampler);
  }
  /*!
   * \brief get interpolation method with given inter_method, 0-CV_INTER_NN 1-CV_INTER_LINEAR 2-CV_INTER_CUBIC
   * \ 3-CV_INTER_AREA 4-CV_INTER_LANCZOS4 9-AUTO(cubic for enlarge, area for shrink, bilinear for others) 10-RAND
   */
  int GetInterMethod(int inter_method, int old_width, int old_height, int new_width,
    int new_height, common::RANDOM_ENGINE *prnd) {
    if (inter_method == 9) {
      if (new_width > old_width && new_height > old_height) {
        return 2;  // CV_INTER_CUBIC for enlarge
      } else if (new_width <old_width && new_height < old_height) {
        return 3;  // CV_INTER_AREA for shrink
      } else {
        return 1;  // CV_INTER_LINEAR for others
      }
      } else if (inter_method == 10) {
      std::uniform_int_distribution<size_t> rand_uniform_int(0, 4);
      return rand_uniform_int(*prnd);
    } else {
      return inter_method;
    }
  }

  /*! \brief Check number of crop samplers and given parameters */
  template<typename DType>
  void ValidateCropParameters(nnvm::Tuple<DType> *param, const int num_sampler) {
    if (num_sampler == 1) {
      CHECK_EQ(param->ndim(), 1);
    } else if (num_sampler > 1) {
      if (param->ndim() == 1) {
        std::vector<DType> vec(num_sampler, (*param)[0]);
        param->assign(vec.begin(), vec.end());
      } else {
        CHECK_EQ(param->ndim(), num_sampler) << "# of parameters/crop_samplers mismatch ";
      }
    }
  }

  /*! \brief Generate crop box region given cropping parameters */
  Rect GenerateCropBox(const float min_crop_scale,
    const float max_crop_scale, const float min_crop_aspect_ratio,
    const float max_crop_aspect_ratio, common::RANDOM_ENGINE *prnd,
    const float img_aspect_ratio) {
    float new_scale = std::uniform_real_distribution<float>(
        min_crop_scale, max_crop_scale)(*prnd) + 1e-12f;
    float min_ratio = std::max<float>(min_crop_aspect_ratio / img_aspect_ratio,
        new_scale * new_scale);
    float max_ratio = std::min<float>(max_crop_aspect_ratio / img_aspect_ratio,
        1. / new_scale * new_scale);
    float new_ratio = std::sqrt(std::uniform_real_distribution<float>(
        min_ratio, max_ratio)(*prnd));
    float new_width = std::min(1.f, new_scale * new_ratio);
    float new_height = std::min(1.f, new_scale / new_ratio);
    float x0 = std::uniform_real_distribution<float>(0.f, 1 - new_width)(*prnd);
    float y0 = std::uniform_real_distribution<float>(0.f, 1 - new_height)(*prnd);
    return Rect(x0, y0, new_width, new_height);
  }

  /*! \brief Generate padding box region given padding parameters */
  Rect GeneratePadBox(const float max_pad_scale,
    common::RANDOM_ENGINE *prnd, const float threshold = 1.05f) {
      float new_scale = std::uniform_real_distribution<float>(
        1.f, max_pad_scale)(*prnd);
      if (new_scale < threshold) return Rect(0, 0, 0, 0);
      auto rand_uniform = std::uniform_real_distribution<float>(0.f, new_scale - 1);
      float x0 = rand_uniform(*prnd);
      float y0 = rand_uniform(*prnd);
      return Rect(-x0, -y0, new_scale, new_scale);
    }
  
  cv::Mat Process(const cv::Mat &src, std::vector<float> *label,
                  common::RANDOM_ENGINE *prnd) override {
    return src;
  }
                  
                  
  cv::Mat Process(const cv::Mat &src, std::vector<float> *label, int &rand_scale_idx,
                          common::RANDOM_ENGINE *prnd, bool &implemented) override {
    implemented = true;
    using mshadow::index_t;
    cv::Mat res;

    // build a helper class for processing labels
    ImageDetLabel det_label(*label);
    // random engine
    std::uniform_real_distribution<float> rand_uniform(0, 1);
    std::uniform_int_distribution<int> rand_scale_idx_uniform(0, param_.num_scale_sampler-1);
    
    // random resize and mute labels by min_area and max_area constraints
    int long_side_scale;
    int short_side_scale;
    float min_area_ratio;
    float max_area_ratio;
    float raw_area = src.cols*src.rows;
    bool success_mute_label = false;
    int new_height;
    int new_width;

    for(int tr_cnt = 0; tr_cnt < 50; tr_cnt++) {
        rand_scale_idx = rand_scale_idx_uniform(*prnd);
        long_side_scale = param_.long_side_scales[rand_scale_idx];
        short_side_scale = param_.short_side_scales[rand_scale_idx];
        min_area_ratio = param_.min_area_ratios[rand_scale_idx];
        max_area_ratio = param_.max_area_ratios[rand_scale_idx];
        
        if (src.rows >= src.cols) {
          new_height = short_side_scale*src.rows/src.cols;
          new_width = short_side_scale;
          
          if(new_height > long_side_scale) {
              new_height = long_side_scale;
              new_width = long_side_scale * src.cols/src.rows;
          }
        } else {
          new_height = short_side_scale;
          new_width = short_side_scale*src.cols/src.rows;
          
          if(new_width > long_side_scale) {
              new_height = long_side_scale*src.rows/src.cols;
              new_width = long_side_scale;
          }
        }
    
        float new_area = new_height*new_width;
        float min_normed_area = param_.target_area * min_area_ratio / new_area;
        float max_normed_area = param_.target_area * max_area_ratio / new_area;
        if(det_label.MuteLabels(min_normed_area, max_normed_area, 1)) {
            success_mute_label = true;
            break;
        }
        
    }
    
    if(success_mute_label == false) {
        throw "success_mute_label == false";
    }
    
    if (src.rows >= src.cols) {
      new_height = short_side_scale*src.rows/src.cols;
      new_width = short_side_scale;
      
      if(new_height > long_side_scale) {
          new_height = long_side_scale;
          new_width = long_side_scale * src.cols/src.rows;
      }
    } else {
      new_height = short_side_scale;
      new_width = short_side_scale*src.cols/src.rows;
      
      if(new_width > long_side_scale) {
          new_height = long_side_scale*src.rows/src.cols;
          new_width = long_side_scale;
      }
    }
    
    if(DEBUG_FLAG) {
        printf("new_width:%d, new_height:%d, min_area_ratio:%f, max_area_ratio:%f, src.rows:%d, src.cols:%d\n", 
            new_width, new_height, min_area_ratio, max_area_ratio, src.rows, src.cols);
    }
    
    int interpolation_method = GetInterMethod(param_.inter_method, 
                                src.cols, src.rows, new_width, new_height, prnd);
    cv::resize(src, res, cv::Size(new_width, new_height), 0, 0, interpolation_method);
    
    
    float h = param_.data_shape[1];
    float w = param_.data_shape[2];
    temp_ = res;
    int left = static_cast<int>(((int)w-new_width)/2);
    int top = static_cast<int>(((int)h-new_height)/2);
    int right = static_cast<int>(((int)w-new_width) - ((int)w-new_width)/2);
    int bot = static_cast<int>(((int)h-new_height) - ((int)h-new_height)/2);
    cv::copyMakeBorder(temp_, res, top, bot, left, right, cv::BORDER_ISOLATED,
            cv::Scalar(param_.fill_value, param_.fill_value, param_.fill_value));
    
    Rect pad_box(-(float)left / new_width, -(float)top / new_height, w / new_width, h / new_height);
    det_label.TryPad(pad_box);

    
    // random mirror logic
    if (param_.rand_mirror_prob > 0 && rand_uniform(*prnd) < param_.rand_mirror_prob) {
      if (det_label.TryMirror()) {
        // flip image
        cv::flip(res, temp_, 1);
        res = temp_;
      }
    }


    if (image_det_aug_multi_scale_enum::kForce == param_.resize_mode) {
      // force resize to specified data_shape, regardless of aspect ratio
      int new_height = param_.data_shape[1];
      int new_width = param_.data_shape[2];
      int interpolation_method = GetInterMethod(param_.inter_method,
                   res.cols, res.rows, new_width, new_height, prnd);
      cv::resize(res, res, cv::Size(new_width, new_height),
                   0, 0, interpolation_method);
    } else if (image_det_aug_multi_scale_enum::kShrink == param_.resize_mode) {
      // try to keep original size, shrink if too large
      float h = param_.data_shape[1];
      float w = param_.data_shape[2];
      if (res.rows > h || res.cols > w) {
        float ratio = std::min(h / res.rows, w / res.cols);
        int new_height = ratio * res.rows;
        int new_width = ratio * res.cols;
        int interpolation_method = GetInterMethod(param_.inter_method,
                     res.cols, res.rows, new_width, new_height, prnd);
        cv::resize(res, res, cv::Size(new_width, new_height),
                    0, 0, interpolation_method);
      }
    } else if (image_det_aug_multi_scale_enum::kFit == param_.resize_mode) {
      float h = param_.data_shape[1];
      float w = param_.data_shape[2];
      float ratio = std::min(h / res.rows, w / res.cols);
      int new_height = ratio * res.rows;
      int new_width = ratio * res.cols;
      int interpolation_method = GetInterMethod(param_.inter_method,
                   res.cols, res.rows, new_width, new_height, prnd);
      cv::resize(res, res, cv::Size(new_width, new_height),
                  0, 0, interpolation_method);
    } else if (image_det_aug_multi_scale_enum::kForceFit == param_.resize_mode) {
      float h = param_.data_shape[1];
      float w = param_.data_shape[2];
      
      int new_width = w;
      int new_height = h;
      if (((float)w/res.cols) < ((float)h/res.rows)) {
        new_width = w;
        new_height = (res.rows * w)/res.cols;
      } else {
        new_height = h;
        new_width = (res.cols * h)/res.rows;
      }
      int interpolation_method = GetInterMethod(param_.inter_method,
                   res.cols, res.rows, new_width, new_height, prnd);
      cv::resize(res, res, cv::Size(new_width, new_height),
                  0, 0, interpolation_method);

      temp_ = res;

      int left = static_cast<int>(((int)w-new_width)/2);
      int top = static_cast<int>(((int)h-new_height)/2);
      int right = static_cast<int>(((int)w-new_width) - ((int)w-new_width)/2);
      int bot = static_cast<int>(((int)h-new_height) - ((int)h-new_height)/2);
      cv::copyMakeBorder(temp_, res, top, bot, left, right, cv::BORDER_ISOLATED,
            cv::Scalar(param_.fill_value, param_.fill_value, param_.fill_value));
      
      Rect pad_box(-(float)left / new_width, -(float)top / new_height, w / new_width, h / new_height);
      det_label.TryPad(pad_box);
    }

    *label = det_label.ToArray();  // put back processed labels
    return res;
  }

 private:
  // temporal space
  cv::Mat temp_;
  // parameters
  MultiScaleImageDetAugmentParam param_;
};

MXNET_REGISTER_IMAGE_AUGMENTER(det_aug_multi_scale)
.describe("multi_scale detection augmenter")
.set_body([]() {
    return new MultiScaleImageDetAugmenter();
  });
#endif  // MXNET_USE_OPENCV
}  // namespace io
}  // namespace mxnet
